
	<sn><md>#### parser_inline.mjs


```js

/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/

import Ruler from './ruler.mjs'
import StateInline from './rules_inline/state_inline.mjs'

import r_text from './rules_inline/text.mjs'
import r_linkify from './rules_inline/linkify.mjs'
import r_newline from './rules_inline/newline.mjs'
import r_escape from './rules_inline/escape.mjs'
import r_backticks from './rules_inline/backticks.mjs'
import r_strikethrough from './rules_inline/strikethrough.mjs'
import r_emphasis from './rules_inline/emphasis.mjs'
import r_link from './rules_inline/link.mjs'
import r_image from './rules_inline/image.mjs'
import r_autolink from './rules_inline/autolink.mjs'
import r_html_inline from './rules_inline/html_inline.mjs'
import r_entity from './rules_inline/entity.mjs'

import r_balance_pairs from './rules_inline/balance_pairs.mjs'
import r_fragments_join from './rules_inline/fragments_join.mjs'

// Parser rules

const _rules = [
  ['text',            r_text],
  ['linkify',         r_linkify],
  ['newline',         r_newline],
  ['escape',          r_escape],
  ['backticks',       r_backticks],
  ['strikethrough',   r_strikethrough.tokenize],
  ['emphasis',        r_emphasis.tokenize],
  ['link',            r_link],
  ['image',           r_image],
  ['autolink',        r_autolink],
  ['html_inline',     r_html_inline],
  ['entity',          r_entity]
]

// `rule2` ruleset was created specifically for emphasis/strikethrough
// post-processing and may be changed in the future.
//
// Don't use this for anything except pairs (plugins working with `balance_pairs`).
//
const _rules2 = [
  ['balance_pairs',   r_balance_pairs],
  ['strikethrough',   r_strikethrough.postProcess],
  ['emphasis',        r_emphasis.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ['fragments_join',  r_fragments_join]
]

/**
 * new ParserInline()
 **/
function ParserInline () {
  /**
   * ParserInline#ruler -&gt; Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler()

  for (let i = 0; i &lt; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1])
  }

  /**
   * ParserInline#ruler2 -&gt; Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler()

  for (let i = 0; i &lt; _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1])
  }
}

// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  const pos = state.pos
  const rules = this.ruler.getRules('')
  const len = rules.length
  const maxNesting = state.md.options.maxNesting
  const cache = state.cache

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos]
    return
  }

  let ok = false

  if (state.level &lt; maxNesting) {
    for (let i = 0; i &lt; len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++
      ok = rules[i](state, true)
      state.level--

      if (ok) {
        if (pos &gt;= state.pos) { throw new Error("inline rule didn't increment state.pos") }
        break
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax
  }

  if (!ok) { state.pos++ }
  cache[pos] = state.pos
}

// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  const rules = this.ruler.getRules('')
  const len = rules.length
  const end = state.posMax
  const maxNesting = state.md.options.maxNesting

  while (state.pos &lt; end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true
    const prevPos = state.pos
    let ok = false

    if (state.level &lt; maxNesting) {
      for (let i = 0; i &lt; len; i++) {
        ok = rules[i](state, false)
        if (ok) {
          if (prevPos &gt;= state.pos) { throw new Error("inline rule didn't increment state.pos") }
          break
        }
      }
    }

    if (ok) {
      if (state.pos &gt;= end) { break }
      continue
    }

    state.pending += state.src[state.pos++]
  }

  if (state.pending) {
    state.pushPending()
  }
}

/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  const state = new this.State(str, md, env, outTokens)

  this.tokenize(state)

  const rules = this.ruler2.getRules('')
  const len = rules.length

  for (let i = 0; i &lt; len; i++) {
    rules[i](state)
  }
}

ParserInline.prototype.State = StateInline

export default ParserInline



```</md></sn>		
	<config>
		<tags>#parser inline.mjs</tags>
		<thumbnail></thumbnail>
		<heading></heading>
		<udate>Thu Jul 31 2025 11:38:12 GMT+0600 (Bangladesh Standard Time)</udate>
		<id>article-pepo6yK4iF</id>
		<duration></duration>
	</config>
<sn><md>### High-Level Overview

* **Block-level** parsing handles structures like paragraphs, blockquotes, lists.
* **Inline-level** parsing handles **text inside blocks**, such as:

  * `**bold**`
  * `_italic_`
  * `` `code` ``
  * `[link](url)`
  * `&lt;`, `&amp;`
  * `*strikethrough*`
  * Line breaks (`\n`)

This class defines how to **tokenize inline syntax** into structured tokens that Markdown-It uses to render HTML.

---

## 1. **Importing Dependencies**

```js
import Ruler from './ruler.mjs'
import StateInline from './rules_inline/state_inline.mjs'
```

* `Ruler`: Manages rules for parsing.
* `StateInline`: Tracks parser state (position, tokens, pending characters, etc.).

```js
// Rule handlers
import r_text from './rules_inline/text.mjs'
import r_linkify from './rules_inline/linkify.mjs'
...
import r_entity from './rules_inline/entity.mjs'
```

Each `r_*` is a function that tokenizes specific inline syntax.

---

## 2. **Defining Rule Sets**

```js
const _rules = [
  ['text', r_text],
  ['linkify', r_linkify],
  ...
  ['entity', r_entity]
]
```

These are the **main inline parsing rules**. Examples:

| Rule Name       | What It Parses            | Example Input          |
| --------------- | ------------------------- | ---------------------- |
| `text`          | Plain text                | `Hello world`          |
| `linkify`       | Auto-links                | `www.google.com`       |
| `newline`       | Soft breaks / hard breaks | `Hello\nWorld`         |
| `escape`        | Escape sequences          | `\*literal asterisks*` |
| `backticks`     | Inline code               | `` `code` ``           |
| `emphasis`      | `*italic*` or `_italic_`  | `*text*`               |
| `strikethrough` | `~~strike~~`              | `~~text~~`             |
| `link`          | Markdown links            | `[link](url)`          |
| `image`         | Markdown images           | `![alt](src)`          |
| `autolink`      | `<http: link="">`           | `<https: x.com="">`      |
| `html_inline`   | Inline HTML               | `<b>bold</b>`          |
| `entity`        | `&amp;`, `&lt;`, etc.     | `&lt;div&gt;`          |

```js
const _rules2 = [
  ['balance_pairs', r_balance_pairs],
  ['strikethrough', r_strikethrough.postProcess],
  ['emphasis', r_emphasis.postProcess],
  ['fragments_join', r_fragments_join]
]
```

* These are **post-processing rules**.
* `balance_pairs`: makes sure `**bold**` is balanced and valid.
* `fragments_join`: combines leftover text pieces back together.

---

## 3. **Constructor**

```js
function ParserInline() {
  this.ruler = new Ruler()
  for (let i = 0; i &lt; _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1])
  }

  this.ruler2 = new Ruler()
  for (let i = 0; i &lt; _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1])
  }
}
```

* Initializes two rulers:

  * `ruler`: main tokenization rules
  * `ruler2`: post-processing rules

---

## 4. **`skipToken(state)`**

Used in validation mode (e.g. while checking emphasis or nesting) to **skip ahead** without generating tokens.

```js
ParserInline.prototype.skipToken = function (state) {
  const pos = state.pos
  ...
  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos]
    return
  }

  let ok = false
  ...
  for (let i = 0; i &lt; len; i++) {
    state.level++
    ok = rules[i](state, true) // validation mode
    state.level--
    ...
  }

  if (!ok) { state.pos++ }
  cache[pos] = state.pos
}
```

### Example:

Input:

```markdown
**bold**
```

When validating if the `**` pairs can be matched:

* It uses `skipToken` to walk through the text.
* Avoids infinite recursion by limiting nesting.
* If parsing fails, it just skips 1 character.

---

## 5. **`tokenize(state)`**

Main inline parsing method — turns inline Markdown into tokens.

```js
ParserInline.prototype.tokenize = function (state) {
  const rules = this.ruler.getRules('')
  const len = rules.length
  const end = state.posMax
  ...
  while (state.pos &lt; end) {
    const prevPos = state.pos
    let ok = false

    if (state.level &lt; maxNesting) {
      for (let i = 0; i &lt; len; i++) {
        ok = rules[i](state, false)
        if (ok) {
          if (prevPos &gt;= state.pos) {
            throw new Error("inline rule didn't increment state.pos")
          }
          break
        }
      }
    }

    if (ok) {
      if (state.pos &gt;= end) break
      continue
    }

    state.pending += state.src[state.pos++]
  }

  if (state.pending) {
    state.pushPending()
  }
}
```

### What It Does:

* Loops through characters in the line.
* Applies each inline rule until one matches.
* If none match, it collects the character as plain text (`pending`).
* When `pending` has content, it creates a `text` token for it.

### Example:

Input:

```markdown
Hello *world*!
```

* At `H`, no rule matches → accumulates `Hello ` as pending.
* At `*`, `emphasis` rule matches → emits `<em>world</em>` token.
* At `!`, gets added to pending.

Final tokens:

```js
[
  { type: 'text', content: 'Hello ' },
  { type: 'em_open' },
  { type: 'text', content: 'world' },
  { type: 'em_close' },
  { type: 'text', content: '!' }
]
```

---

## 6. **`parse(str, md, env, outTokens)`**

High-level API to parse inline text.

```js
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  const state = new this.State(str, md, env, outTokens)

  this.tokenize(state)

  const rules = this.ruler2.getRules('')
  for (let i = 0; i &lt; rules.length; i++) {
    rules[i](state)
  }
}
```

### What Happens:

* Creates `StateInline` object for this input string.
* Calls `tokenize()` to generate basic inline tokens.
* Then applies `ruler2` rules to fix/improve tokens:

  * Match emphasis/strikethrough pairs
  * Merge unused fragments back

---

## Final Summary

| Component     | Purpose                                             |
| ------------- | --------------------------------------------------- |
| `ruler`       | Main inline parsing rules                           |
| `ruler2`      | Post-processing (like pairing emphasis)             |
| `skipToken()` | Used during validation to skip token                |
| `tokenize()`  | Main tokenization method (creates tokens)           |
| `parse()`     | Public method that applies `tokenize + postprocess` |

---

## Example: `**Bold** and _italic_`

```markdown
**Bold** and _italic_
```

1. **Tokenize:**

   * Finds `**`, creates potential strong marker.
   * Finds `and _`, creates emphasis marker.
2. **Post-process:**

   * Matches pairs: `**...**` → `<strong>`, `_..._` → `<em>`

**Tokens:**

```js
[
  { type: 'strong_open' },
  { type: 'text', content: 'Bold' },
  { type: 'strong_close' },
  { type: 'text', content: ' and ' },
  { type: 'em_open' },
  { type: 'text', content: 'italic' },
  { type: 'em_close' }
]
```
</em></strong></https:></http:></md></sn><sn><md>###  _Markdown Template_</md></sn>