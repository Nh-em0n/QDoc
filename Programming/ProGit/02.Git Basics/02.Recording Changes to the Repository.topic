<sn><md>## Recording Changes to the Repository
---

At this point, you should have a bona fide Git repository on your local machine, and a checkout or working copy of all of its files in front of you. Typically, you’ll want to start making changes and committing snapshots of those changes into your repository each time the project reaches a state you want to record.



### Tracked vs. Untracked Files
---

* **Tracked files**
  Files that were in the last snapshot, as well as any newly staged files. They can be:

  * Unmodified
  * Modified
  * Staged
    In short, tracked files are files that Git knows about.

* **Untracked files**
  Files in your working directory that:

  * Were not in your last snapshot
  * Are not in your staging area

When you first clone a repository, all files will be *tracked and unmodified* because Git just checked them out and you haven’t edited anything yet.

---

![diagram](https://i.imgur.com/VJNYpsh.png)


**The Modify–Stage–Commit Cycle**

As you edit files:

* Git marks them as **modified** (changed since your last commit).
* You **stage** the modified files you want to include in the next commit.
* You **commit** the staged files to the repository.

This cycle then repeats.

---

**Figure 8.** The lifecycle of the status of your files
</md></sn><sn><md>## Checking the Status of Your Files
---

The main tool you use to determine which files are in which state is the `git status` command. If you run this command directly after a clone, you should see something like:

```bash
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```

This output means:

* Your working directory is clean (none of your tracked files have been modified).
* There are no untracked files (otherwise, they would be listed).
* You're on the `master` branch, which is in sync with the `origin/master` on the server.

Although Git uses `master` as the default branch, note:

&gt; GitHub changed the default branch name from `master` to `main` in mid-2020, and other Git hosts followed. You may see `main` or a custom branch name depending on your repository settings.
&gt; However, Git itself still uses `master` as the default, so we will use it throughout this book.


### Untracked Files Example
---

Let’s say you add a new file to your project—a simple README file. If it didn’t exist before and you run `git status`, you’ll see:

```bash
$ echo 'My Project' &gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
  README

nothing added to commit but untracked files present (use "git add" to track)
```

The new `README` file appears under the **Untracked files** heading because:

* It wasn’t in the last snapshot (commit).
* It hasn’t been staged yet.

Git won’t include untracked files in commits until you explicitly tell it to with `git add`. This prevents accidentally committing temporary or generated files.

Since you do want to start tracking `README`, you’ll need to explicitly stage it.
^^undefined^^undefined</file></md></sn><config style="display:none"><tags>#02.recording changes to the repository</tags><thumbnail></thumbnail><heading></heading><udate>Sun Jun 01 2025 22:43:05 GMT+0600 (Bangladesh Standard Time)</udate><id>article-4EuNVZlCAI</id><duration></duration></config><sn><md>## Tracking New Files
---

#### Adding New Files to Git

To begin tracking a new file, use the `git add` command. For example, to start tracking a `README` file:

```
$ git add README
```

#### Checking Status After Adding

After running the `git add` command, check the status:

```
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  
Changes to be committed:  
  (use "git restore --staged <file class="undefined d-none">..." to unstage)  
  new file: README
```

You’ll notice that the `README` file is now tracked and **staged** for the next commit. It's listed under the **"Changes to be committed"** heading, indicating that it will be included in the next snapshot if you run `git commit`.

### Behavior of `git add`

The `git add` command saves the version of the file as it existed at the time of the command. Any subsequent changes must be staged again if you want them included.

When you ran `git init` earlier and then executed `git add <files>`, it started tracking all existing files. The `git add` command accepts:

* A single file path
* A directory path (recursively adds all files inside)
</files></file></md></sn><sn><md>## Staging Modified Files

### Modifying a Tracked File

Suppose you modify a previously tracked file, such as `CONTRIBUTING.md`, and then run:

```
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  

Changes not staged for commit:  
  (use "git add <file class="undefined d-none">..." to update what will be committed)  
  (use "git checkout -- <file class="undefined d-none">..." to discard changes in working directory)  
  modified: CONTRIBUTING.md
```

The file appears under **"Changes not staged for commit"**, which means it's tracked and modified but not staged.

### Staging the Modified File

To stage the modified file, use:

```
$ git add CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md
```

Now both files are staged and ready for the next commit.

### Editing Again After Staging

Suppose you remember another edit for `CONTRIBUTING.md`, make the change, and then check the status:

```
$ vim CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md  

Changes not staged for commit:  
  (use "git add <file class="undefined d-none">..." to update what will be committed)  
  (use "git checkout -- <file class="undefined d-none">..." to discard changes in working directory)  
  modified: CONTRIBUTING.md
```

Now `CONTRIBUTING.md` appears in both staged and unstaged sections.

### Why This Happens

Git stages the **exact version** of a file at the moment you run `git add`. If you modify the file afterward, those changes are not yet staged. To stage the updated content, run:

```
$ git add CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md
```

Now the most recent version of the file is staged and ready to be committed.
</file></file></file></file></file></file></file></file></md></sn><sn><md>## Short Status
---

### Using the Short Status Flag

While the default `git status` output is detailed, it can be verbose. For a more compact summary, use the **short status** flag:

```
$ git status -s
```

or

```
$ git status --short
```

Example output:

```
 M README  
MM Rakefile  
A  lib/git.rb  
M  lib/simplegit.rb  
?? LICENSE.txt
```

### Interpreting Short Status Output

* `??` — New, **untracked** files (e.g., `LICENSE.txt`)
* `A` — New file **added to the staging area** (e.g., `lib/git.rb`)
* `M` — File **modified**

There are two columns:

* **Left column** = Status in the **staging area**
* **Right column** = Status in the **working directory**

#### Example Breakdown:

* ` M README`
  → Modified in the **working directory**, not staged

* `MM Rakefile`
  → Modified in both the **staging area** and the **working directory**

* `A  lib/git.rb`
  → Newly **added** and **staged**

* `M  lib/simplegit.rb`
  → Modified and **staged**

* `?? LICENSE.txt`
  → **Untracked** file

This concise format is ideal for quickly checking your working state.
</md></sn><sn><md>## Ignoring Files
---

#### Purpose of `.gitignore`

In many projects, there are files you don't want Git to track—such as:

* Automatically generated files (e.g., logs, build outputs)
* Temporary or editor-specific files

To prevent Git from showing these as untracked or accidentally adding them, use a `.gitignore` file with pattern rules to specify which files or directories should be ignored.

#### Example `.gitignore` File

```bash
$ cat .gitignore
*.[oa]
*~
```

* `*.[oa]` — Ignores files ending in `.o` or `.a` (object and archive files)
* `*~` — Ignores files ending in `~` (temporary files created by editors like Emacs)

Other common entries include:

* `log/`, `tmp/`, `*.pid` — Log and temp directories, PID files
* `*.log`, `*.tmp`, `*.swp` — Editor and build leftovers

Setting up `.gitignore` early helps avoid committing unwanted files.

#### `.gitignore` Pattern Rules

##### Basic Rules

* Blank lines or lines starting with `#` are ignored (comments)
* Patterns use **glob syntax** and apply **recursively**
* Prefixing a pattern with `/` makes it relative to the `.gitignore` location
* Ending with `/` specifies a directory
* Prefixing with `!` negates a pattern (excludes it from being ignored)

##### Glob Syntax Overview

* `*` — Matches 0 or more characters
* `?` — Matches a single character
* `[abc]` — Matches any of the listed characters
* `[0-9]` — Matches any digit from 0 to 9
* `**` — Matches directories recursively

#### Advanced Example

```bash
# Ignore all .a files
*.a

# But track lib.a even though .a files are ignored
!lib.a

# Ignore TODO only in the root directory
/TODO

# Ignore all files in any build directory
build/

# Ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# Ignore all PDFs in doc/ and its subdirectories
doc/**/*.pdf
```

#### Repository-Wide vs. Directory-Specific `.gitignore`

* A `.gitignore` in the root applies **recursively** to all subdirectories.
* You can also create `.gitignore` files **in subdirectories** to apply rules only to that folder and its children.

&gt; Example: The Linux kernel repo has over 200 `.gitignore` files scoped to individual folders.

For deeper customization and rules, refer to the manual:

```
man gitignore
```

Or explore community-maintained templates for various languages and tools:

**GitHub’s `.gitignore` collection**:
[https://github.com/github/gitignore](https://github.com/github/gitignore)
</md></sn>