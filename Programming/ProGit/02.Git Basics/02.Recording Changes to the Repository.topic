<sn><md>## Recording Changes to the Repository
---

At this point, you should have a bona fide Git repository on your local machine, and a checkout or working copy of all of its files in front of you. Typically, you’ll want to start making changes and committing snapshots of those changes into your repository each time the project reaches a state you want to record.



### Tracked vs. Untracked Files
---

* **Tracked files**
  Files that were in the last snapshot, as well as any newly staged files. They can be:

  * Unmodified
  * Modified
  * Staged
    In short, tracked files are files that Git knows about.

* **Untracked files**
  Files in your working directory that:

  * Were not in your last snapshot
  * Are not in your staging area

When you first clone a repository, all files will be *tracked and unmodified* because Git just checked them out and you haven’t edited anything yet.

---

![diagram](https://i.imgur.com/VJNYpsh.png)


**The Modify–Stage–Commit Cycle**

As you edit files:

* Git marks them as **modified** (changed since your last commit).
* You **stage** the modified files you want to include in the next commit.
* You **commit** the staged files to the repository.

This cycle then repeats.

---

**Figure 8.** The lifecycle of the status of your files
</md></sn><sn><md>## Checking the Status of Your Files
---

The main tool you use to determine which files are in which state is the `git status` command. If you run this command directly after a clone, you should see something like:

```bash
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```

This output means:

* Your working directory is clean (none of your tracked files have been modified).
* There are no untracked files (otherwise, they would be listed).
* You're on the `master` branch, which is in sync with the `origin/master` on the server.

Although Git uses `master` as the default branch, note:

&gt; GitHub changed the default branch name from `master` to `main` in mid-2020, and other Git hosts followed. You may see `main` or a custom branch name depending on your repository settings.
&gt; However, Git itself still uses `master` as the default, so we will use it throughout this book.


### Untracked Files Example
---

Let’s say you add a new file to your project—a simple README file. If it didn’t exist before and you run `git status`, you’ll see:

```bash
$ echo 'My Project' &gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
  README

nothing added to commit but untracked files present (use "git add" to track)
```

The new `README` file appears under the **Untracked files** heading because:

* It wasn’t in the last snapshot (commit).
* It hasn’t been staged yet.

Git won’t include untracked files in commits until you explicitly tell it to with `git add`. This prevents accidentally committing temporary or generated files.

Since you do want to start tracking `README`, you’ll need to explicitly stage it.
^^undefined^^undefined</file></md></sn><config style="display:none"><tags>#02.recording changes to the repository</tags><thumbnail></thumbnail><heading></heading><udate>Sun Jun 01 2025 22:35:57 GMT+0600 (Bangladesh Standard Time)</udate><id>article-4EuNVZlCAI</id><duration></duration></config><sn><md>## Tracking New Files
---

#### Adding New Files to Git

To begin tracking a new file, use the `git add` command. For example, to start tracking a `README` file:

```
$ git add README
```

#### Checking Status After Adding

After running the `git add` command, check the status:

```
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  
Changes to be committed:  
  (use "git restore --staged <file class="undefined d-none">..." to unstage)  
  new file: README
```

You’ll notice that the `README` file is now tracked and **staged** for the next commit. It's listed under the **"Changes to be committed"** heading, indicating that it will be included in the next snapshot if you run `git commit`.

### Behavior of `git add`

The `git add` command saves the version of the file as it existed at the time of the command. Any subsequent changes must be staged again if you want them included.

When you ran `git init` earlier and then executed `git add <files>`, it started tracking all existing files. The `git add` command accepts:

* A single file path
* A directory path (recursively adds all files inside)
</files></file></md></sn><sn><md>## Staging Modified Files

### Modifying a Tracked File

Suppose you modify a previously tracked file, such as `CONTRIBUTING.md`, and then run:

```
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  

Changes not staged for commit:  
  (use "git add <file class="undefined d-none">..." to update what will be committed)  
  (use "git checkout -- <file class="undefined d-none">..." to discard changes in working directory)  
  modified: CONTRIBUTING.md
```

The file appears under **"Changes not staged for commit"**, which means it's tracked and modified but not staged.

### Staging the Modified File

To stage the modified file, use:

```
$ git add CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md
```

Now both files are staged and ready for the next commit.

### Editing Again After Staging

Suppose you remember another edit for `CONTRIBUTING.md`, make the change, and then check the status:

```
$ vim CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md  

Changes not staged for commit:  
  (use "git add <file class="undefined d-none">..." to update what will be committed)  
  (use "git checkout -- <file class="undefined d-none">..." to discard changes in working directory)  
  modified: CONTRIBUTING.md
```

Now `CONTRIBUTING.md` appears in both staged and unstaged sections.

### Why This Happens

Git stages the **exact version** of a file at the moment you run `git add`. If you modify the file afterward, those changes are not yet staged. To stage the updated content, run:

```
$ git add CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md
```

Now the most recent version of the file is staged and ready to be committed.
</file></file></file></file></file></file></file></file></md></sn>