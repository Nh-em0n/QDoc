<sn><md>## Recording Changes to the Repository
---

At this point, you should have a bona fide Git repository on your local machine, and a checkout or working copy of all of its files in front of you. Typically, you’ll want to start making changes and committing snapshots of those changes into your repository each time the project reaches a state you want to record.



### Tracked vs. Untracked Files
---

* **Tracked files**
  Files that were in the last snapshot, as well as any newly staged files. They can be:

  * Unmodified
  * Modified
  * Staged
    In short, tracked files are files that Git knows about.

* **Untracked files**
  Files in your working directory that:

  * Were not in your last snapshot
  * Are not in your staging area

When you first clone a repository, all files will be *tracked and unmodified* because Git just checked them out and you haven’t edited anything yet.

---

![diagram](https://i.imgur.com/VJNYpsh.png)


**The Modify–Stage–Commit Cycle**

As you edit files:

* Git marks them as **modified** (changed since your last commit).
* You **stage** the modified files you want to include in the next commit.
* You **commit** the staged files to the repository.

This cycle then repeats.

---

**Figure 8.** The lifecycle of the status of your files
</md></sn><sn><md>## Checking the Status of Your Files
---

The main tool you use to determine which files are in which state is the `git status` command. If you run this command directly after a clone, you should see something like:

```bash
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```

This output means:

* Your working directory is clean (none of your tracked files have been modified).
* There are no untracked files (otherwise, they would be listed).
* You're on the `master` branch, which is in sync with the `origin/master` on the server.

Although Git uses `master` as the default branch, note:

&gt; GitHub changed the default branch name from `master` to `main` in mid-2020, and other Git hosts followed. You may see `main` or a custom branch name depending on your repository settings.
&gt; However, Git itself still uses `master` as the default, so we will use it throughout this book.


### Untracked Files Example
---

Let’s say you add a new file to your project—a simple README file. If it didn’t exist before and you run `git status`, you’ll see:

```bash
$ echo 'My Project' &gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)
  README

nothing added to commit but untracked files present (use "git add" to track)
```

The new `README` file appears under the **Untracked files** heading because:

* It wasn’t in the last snapshot (commit).
* It hasn’t been staged yet.

Git won’t include untracked files in commits until you explicitly tell it to with `git add`. This prevents accidentally committing temporary or generated files.

Since you do want to start tracking `README`, you’ll need to explicitly stage it.
^^undefined^^undefined</file></md></sn><config style="display:none"><tags>#02.recording changes to the repository</tags><thumbnail></thumbnail><heading></heading><udate>Sun Jun 01 2025 22:48:27 GMT+0600 (Bangladesh Standard Time)</udate><id>article-4EuNVZlCAI</id><duration></duration></config><sn><md>## Tracking New Files
---

#### Adding New Files to Git

To begin tracking a new file, use the `git add` command. For example, to start tracking a `README` file:

```
$ git add README
```

#### Checking Status After Adding

After running the `git add` command, check the status:

```
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  
Changes to be committed:  
  (use "git restore --staged <file class="undefined d-none">..." to unstage)  
  new file: README
```

You’ll notice that the `README` file is now tracked and **staged** for the next commit. It's listed under the **"Changes to be committed"** heading, indicating that it will be included in the next snapshot if you run `git commit`.

### Behavior of `git add`

The `git add` command saves the version of the file as it existed at the time of the command. Any subsequent changes must be staged again if you want them included.

When you ran `git init` earlier and then executed `git add <files>`, it started tracking all existing files. The `git add` command accepts:

* A single file path
* A directory path (recursively adds all files inside)
</files></file></md></sn><sn><md>## Staging Modified Files

### Modifying a Tracked File

Suppose you modify a previously tracked file, such as `CONTRIBUTING.md`, and then run:

```
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  

Changes not staged for commit:  
  (use "git add <file class="undefined d-none">..." to update what will be committed)  
  (use "git checkout -- <file class="undefined d-none">..." to discard changes in working directory)  
  modified: CONTRIBUTING.md
```

The file appears under **"Changes not staged for commit"**, which means it's tracked and modified but not staged.

### Staging the Modified File

To stage the modified file, use:

```
$ git add CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md
```

Now both files are staged and ready for the next commit.

### Editing Again After Staging

Suppose you remember another edit for `CONTRIBUTING.md`, make the change, and then check the status:

```
$ vim CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md  

Changes not staged for commit:  
  (use "git add <file class="undefined d-none">..." to update what will be committed)  
  (use "git checkout -- <file class="undefined d-none">..." to discard changes in working directory)  
  modified: CONTRIBUTING.md
```

Now `CONTRIBUTING.md` appears in both staged and unstaged sections.

### Why This Happens

Git stages the **exact version** of a file at the moment you run `git add`. If you modify the file afterward, those changes are not yet staged. To stage the updated content, run:

```
$ git add CONTRIBUTING.md
$ git status
On branch master  
Your branch is up-to-date with 'origin/master'.  

Changes to be committed:  
  (use "git reset HEAD <file class="undefined d-none">..." to unstage)  
  new file: README  
  modified: CONTRIBUTING.md
```

Now the most recent version of the file is staged and ready to be committed.
</file></file></file></file></file></file></file></file></md></sn><sn><md>## Short Status
---

### Using the Short Status Flag

While the default `git status` output is detailed, it can be verbose. For a more compact summary, use the **short status** flag:

```
$ git status -s
```

or

```
$ git status --short
```

Example output:

```
 M README  
MM Rakefile  
A  lib/git.rb  
M  lib/simplegit.rb  
?? LICENSE.txt
```

### Interpreting Short Status Output

* `??` — New, **untracked** files (e.g., `LICENSE.txt`)
* `A` — New file **added to the staging area** (e.g., `lib/git.rb`)
* `M` — File **modified**

There are two columns:

* **Left column** = Status in the **staging area**
* **Right column** = Status in the **working directory**

#### Example Breakdown:

* ` M README`
  → Modified in the **working directory**, not staged

* `MM Rakefile`
  → Modified in both the **staging area** and the **working directory**

* `A  lib/git.rb`
  → Newly **added** and **staged**

* `M  lib/simplegit.rb`
  → Modified and **staged**

* `?? LICENSE.txt`
  → **Untracked** file

This concise format is ideal for quickly checking your working state.
</md></sn><sn><md>## Ignoring Files
---

#### Purpose of `.gitignore`

In many projects, there are files you don't want Git to track—such as:

* Automatically generated files (e.g., logs, build outputs)
* Temporary or editor-specific files

To prevent Git from showing these as untracked or accidentally adding them, use a `.gitignore` file with pattern rules to specify which files or directories should be ignored.

#### Example `.gitignore` File

```bash
$ cat .gitignore
*.[oa]
*~
```

* `*.[oa]` — Ignores files ending in `.o` or `.a` (object and archive files)
* `*~` — Ignores files ending in `~` (temporary files created by editors like Emacs)

Other common entries include:

* `log/`, `tmp/`, `*.pid` — Log and temp directories, PID files
* `*.log`, `*.tmp`, `*.swp` — Editor and build leftovers

Setting up `.gitignore` early helps avoid committing unwanted files.

#### `.gitignore` Pattern Rules

##### Basic Rules

* Blank lines or lines starting with `#` are ignored (comments)
* Patterns use **glob syntax** and apply **recursively**
* Prefixing a pattern with `/` makes it relative to the `.gitignore` location
* Ending with `/` specifies a directory
* Prefixing with `!` negates a pattern (excludes it from being ignored)

##### Glob Syntax Overview

* `*` — Matches 0 or more characters
* `?` — Matches a single character
* `[abc]` — Matches any of the listed characters
* `[0-9]` — Matches any digit from 0 to 9
* `**` — Matches directories recursively

#### Advanced Example

```bash
# Ignore all .a files
*.a

# But track lib.a even though .a files are ignored
!lib.a

# Ignore TODO only in the root directory
/TODO

# Ignore all files in any build directory
build/

# Ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# Ignore all PDFs in doc/ and its subdirectories
doc/**/*.pdf
```

#### Repository-Wide vs. Directory-Specific `.gitignore`

* A `.gitignore` in the root applies **recursively** to all subdirectories.
* You can also create `.gitignore` files **in subdirectories** to apply rules only to that folder and its children.

&gt; Example: The Linux kernel repo has over 200 `.gitignore` files scoped to individual folders.

For deeper customization and rules, refer to the manual:

```
man gitignore
```

Or explore community-maintained templates for various languages and tools:

**GitHub’s `.gitignore` collection**:
[https://github.com/github/gitignore](https://github.com/github/gitignore)
</md></sn><sn><md>## Viewing Your Staged and Unstaged Changes
---


#### When `git status` Isn’t Enough

While `git status` shows **which** files have changed, it doesn’t show **how** they’ve changed. To view the specific line-by-line changes in your files, use the `git diff` command. This command helps answer:

* What have you changed but **not yet staged**?
* What have you staged that is ready to be **committed**?

#### Unstaged Changes: `git diff`

If you want to see what’s changed in your working directory that hasn’t been staged yet:

```bash
$ git diff
```

Example:

```bash
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@
Please include a nice description of your changes when you submit your PR;
if we have to read the whole diff to figure out why you're contributing
in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.
```

This shows exactly what lines were added or removed compared to the last staged snapshot.

#### Staged Changes: `git diff --staged` or `git diff --cached`

To see what’s been staged (and will go into the next commit):

```bash
$ git diff --staged
```

or

```bash
$ git diff --cached
```

Example:

```bash
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
```

&gt; If all changes are staged, running `git diff` will return no output, because there’s nothing left unstaged.

### Seeing Both Staged and Unstaged Changes in the Same File

Let’s say you stage a file, then edit it again:

```bash
$ git add CONTRIBUTING.md
$ echo '# test line' &gt;&gt; CONTRIBUTING.md
```

Now run:

```bash
$ git status
```

```
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  modified: CONTRIBUTING.md
Changes not staged for commit:
  modified: CONTRIBUTING.md
```

Now view the unstaged change:

```bash
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@
## Starter Projects
See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
```

And view the staged change:

```bash
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@
Please include a nice description of your changes when you submit your PR;
if we have to read the whole diff to figure out why you're contributing
in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.
```

#### Viewing Diffs in an External Tool: `git difftool`

You can use external tools for a graphical diff view:

```bash
$ git difftool
```

To see what tools are available:

```bash
$ git difftool --tool-help
```

Tools may include:

* `vimdiff`
* `meld`
* `kdiff3`
* `emerge`
* Commercial apps

These external tools provide more visual comparisons, which can be easier to work with than raw terminal diffs.
</md></sn><sn><md>## Committing Your Changes

### What Gets Committed?

When you're ready to save a snapshot of your work, you use the `git commit` command. But remember:

* **Only staged changes** (those added with `git add`) will be committed.
* **Unstaged changes** will remain in your working directory.

So always check your staging area with `git status` before committing.

---

### Committing with an Editor

The basic form of the commit command:

```bash
$ git commit
```

This opens your configured text editor (such as `vim`, `nano`, or `emacs`) to write a commit message.

If you're using `vim`, you may see something like this:

```
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#   new file:   README
#   modified:   CONTRIBUTING.md
```

* Lines starting with `#` are comments and will be ignored.
* The commit message goes above or in place of the comment block.

To configure your preferred editor:

```bash
$ git config --global core.editor nano  # or 'vim', 'code --wait', etc.
```

---

### Adding a Diff to the Commit Editor

You can use the `-v` (verbose) option to include the diff in the commit editor window:

```bash
$ git commit -v
```

This lets you see the exact changes you’re committing while writing your message.

---

### Inline Commit Message with `-m`

To avoid opening an editor, use the `-m` flag followed by your message:

```bash
$ git commit -m "Story 182: fix benchmarks for speed"
```

Output example:

```
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
```

* You see the branch (`master`)
* The commit ID (`463dc4f`)
* A summary of changes (files and lines modified)

---

### Summary

* `git commit` saves the **staged snapshot** to history.
* Use `git add` to select changes for the next commit.
* Use `git commit` or `git commit -m "message"` to record those changes.
* Anything not staged will remain as modified and can be committed later.

Every commit creates a point in history you can return to or compare against, making version tracking in Git both powerful and flexible.
</md></sn>